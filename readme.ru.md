# Existence Ontology: решение "экзистенциальных" вопросов
**[English version](readme.md)**

## О проекте

Порой, я смотрю в код и думаю: а существует ли этот объект? И что вообще значит
"существовать" для него? Понятно, что если в этой переменной лежит null - её значение не
имеет никакого смысла для нас. Если это Optional - его можно спросить `o.isPresent()`? - и
получить ответ. Но что если внутри того Optional - лежит ещё один Optional?
Или, вот, возьмем в пример строку, состоящую из пробелов. Метод
`"     ".isEmpty()` считает, что она не пустая, но полезной информации в ней ноль! А
сколько бизнес объектов, которые могут быть
"пустыми", если, предположим, на форме не заполнили обязательные поля...

Existence Ontology призвана решить эти проблемы при помощи создания системы правил и
удобных интерфейсов для их использования. Любые конструктивные предложения по улучшению
сформулированные в дружелюбной форме - принимаются с благодарностью.

## Компоненты

- `core`
    - **Описание**: базовая библиотека разработанная на java 8 без использования сторонних
      зависимостей (только для тестирования). Позволяет создавать ExistenceChecker который
      умеет проводить все интересующие меня тесты объектов. Содержит готовую имплементацию
      чекера и правил для проверки, которые показались мне полезными.

    - **Статус**: `IN PROGRESS`
- `lombok-utils`
    - **Описание**: библиотека содержащая класс ExistenceUtils позволяющий выполнять
      проверки на существование без создания экземпляра ExistenceChecker. А так
      же `@ExtensionMethod` (Слава Ломбоку!) для класса Object
    - **Статус**: `CONSIDERING`
    - **Причины**: ExistenceUtils должна содержать в себе статическое поле с экземпляром
      ExistenceChecker. Однако, что в нем толку без возможности добавить свои правила. А
      давать возможность модифицировать, по сути, глобальную переменную из любого места не
      безопасно. Однако, как же удобно...
- `spring-starter`
    - Описание: Обычный стартер, который предоставит преконфигурированные бины
      ExistenceChecker, возможность сканирования и автоматической регистрации правил по
      пакету и списку названий. Spring Boot 3, Java 21.
    - **Статус**: `TODO`

---

# Правила работы с ветками и версионированием

Проект использует ручное версионирование по схеме [**SemVer (X.Y.Z)**](https://semver.org/):

- **X** — major: несовместимые изменения (breaking changes)
- **Y** — minor: новые фичи без поломки обратной совместимости
- **Z** — patch: багфиксы и правки без изменения контракта

## Основные ветки

- **`master`** — содержит только **стабильные опубликованные версии**.  
  Попадание в `master` происходит:
    - либо через merge из `rc/*`,
    - либо через merge из `fix/*`.

- **`rc/module-x.y.0`** — ветка подготовки релиза.  
  Отбивается от `master`, принимает все новые фичи в конкретный модуль.  
  Версия обновляется **только здесь**.  
  После стабилизации и финального тестирования вливается в `master` и тегируется.

- **`feature/*`** — рабочие ветки для новых возможностей.  
  Отбиваются от `rc/module-x.y.0`.  
  Версию не трогают.
  После завершения изменений — создаётся Merge Request в соответствующий `rc/module-x.y.0`.

- **`fix/module-x.y.z-*`** — быстрые исправления багов.  
  Отбиваются от `master`, версию увеличивают по Z.  
  Часть с текстовым описанием изменений заполняется через нижнее подчеркивание. например:
  `fix/core-1.5.0-nullpointer_in_static_beans`
  После завершения — Merge Request в `master` + ручной bump версии.

## Пример процесса релиза

1. Сразу же после влива прошлого релиза `core` от `master` создаётся ветка для следующего rc `rc/core-1.5.0`.
2. Все фичи разрабатываются в `feature/*` и вливаются в `rc/core-1.5.0` через Merge Request.
3. Версия устанавливается и обновляется вручную **в ветке `rc/1.5.0`**, один раз, ближе к завершению. При
   необходимости (например, не терпящем отлагательств несовместимом изменении) номер версии и название ветки могут быть
   изменены.
4. Когда ветка готова:
    - в неё больше ничего не вливается,
    - она вливается в `master`,
    - на коммит ставится тег: `core-v1.5.0`
    - публикация (если есть) происходит по тегу.

## Пример процесса хотфикса

1. От `master` создаётся ветка `fix/core-1.5.1-some_bug`.
2. Вносится исправление.
3. Повышается версия: `1.5.1`
4. Ветка вливается в `master`, создаётся тег `core-v1.5.1`.

## Общие правила

- В **`feature/*` ветках нельзя трогать версию**.
- Версию меняют **только в `rc/*` и `fix/*` ветках**.
- Публикация происходит **только из `master` по тегу**, ручному или через CI.
- Каждый тег `module-vX.Y.Z` указывает на коммит с соответствующей версией в коде.
- Каждый MR должен сопровождаться описанием изменений на русском или английском в формате markdown
- При мердже используется Fast Forward. Коммиты сквошатся, заголовком становится название фича-ветки, а телом - описание
  MR.
